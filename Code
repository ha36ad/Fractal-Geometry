import turtle
tt=turtle.Turtle()
#tree
#main function:
def recursion(length):
    if length<10:
        return
    else:
        tt.forward(length)
        tt.left(30)
        recursion(3*length/4)
        tt.right(60)
        recursion(3*length/4)
        tt.left(30)
        tt.backward(length)
recursion(100)
#dragon curve
limit = 1
#left and right
left = 'l'
right = 'r'
#axiom
intial = right
new = intial
#ask user for input
iteration = int(input("Enter # of iterations : "))
length = int(input("Enter length of each segment : "))
#rules:
while limit<iteration: 
        new = intial + right
        intial = intial[:: -1]
        for i in range(0, len(intial)):  
                if intial[i] == right:
                        intial = (intial[:i])+ (left) + (intial[i + 1:]) 
                elif intial[i] == left:
                        intial = (intial[:i]) + (right) + (intial[i + 1:])                                                              
        new = (new) + (intial)  
        intial = new                                     
        limit += 1
#turtle
turtle.ht() 
turtle.speed(0)  
turtle.color="blue"  
turtle.bgcolor="green"
turtle.forward(length)
tt=turtle.Turtle()
#main function
for i in range(0, len(new)):  
    if new[i] == (right):  
        turtle.right(90)  
        turtle.forward(length) 
    elif new[i] == (left):     
        turtle.left(90) 
        turtle.forward(length) 
#Koch Curve
def flake(length, limit):
    if limit == 0:
        turtle.forward(length)
        return
    length /= 3.00
    flake(length, limit-1)
    turtle.left(60)
    flake(length, limit-1)
    turtle.right(120)
    flake(length, limit-1)
    turtle.left(60)
    flake(length, limit-1)
#turtle
turtle.speed(0)
length=300.0
turtle.backward(length/2)
#replication
for i in range(6):
    flake(length, 7)
    turtle.right(120)

    
                  
        
        
  
